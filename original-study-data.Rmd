---
title: "Minimal groups analysis"
author: "Matt Jaquiery (matt.jaquiery@psy.ox.ac.uk)"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '3'
    # css: ../src/writeUp.css
    # includes:
      # after_body: ../src/toc_menu.html
  html_notebook:
    toc: yes
    toc_depth: 3
editor_options:
  chunk_output_type: inline
---

September 2019

[Script run `r Sys.time()`]

```{r libraries, include=F}

library(tidyverse)  # data wrangling
library(R.matlab)   # import data from MATLAB files

library(ez)         # ANOVA functions with nice mixed syntax

theme_set(theme_light() + theme(
  panel.grid = element_blank()
))

# rainclouds courtesy of Micah Allen
# https://micahallen.org/2018/03/15/introducing-raincloud-plots/
raincloud_theme = theme(
  text = element_text(size = 10),
  axis.title.x = element_text(size = 16),
  axis.title.y = element_text(size = 16),
  axis.text = element_text(size = 14),
  axis.text.x = element_text(angle = 45, vjust = 0.5),
  legend.title = element_text(size = 16),
  legend.text = element_text(size = 16),
  legend.position = "right",
  plot.title = element_text(lineheight = .8, face = "bold", size = 16),
  panel.border = element_blank(),
  panel.grid.minor = element_blank(),
  panel.grid.major = element_blank(),
  axis.line.x = element_line(colour = 'black', size = 0.5, linetype = 'solid'),
  axis.line.y = element_line(colour = 'black', size = 0.5, linetype = 'solid')
  )
source("https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R")

```

# Feelings of Responsibility by Receivership of Reward
## Marwa El Zein and Matt Jaquiery. 

People’s sense of responsibility for decisions is strongly dependent on the success of the outcome

## Magnitude of the outcome

Sofia Bonicalzi 's poster showed that people judged to feel more **in control** when the magnitude of outcome was larger. We can attempt to replicate this with **responsibility rating** and in the context of **group decisions**.

## Group members where the reward is given to only one member (participant/other)

### Is less effort put in/agency felt if they are told beforehand that someone else is getting the reward?

Pat Lockwood’s study on effort expended for self/other rewards

### Are responsibility ratings higher where participant rather than partner gets the reward from a join decision?
     
Paradigm: participants do group decisions (similar to the paradigm of my responsibility study), at the time of the decision they don't know yet who will get the outcome (and they judge how responsible here, which is the baseline of their sense of responsibility while doing a group decision), and at the time where the outcome is shown, they also get the information about who actually got the outcome (participant/other) - and there we can compare the change in their sense of responsibility before and after the outcome, and how it varies as a function of who get the outcome. 

Alternative: show who gets the outcome before the outcome, to see whether even independently of the valence, the sense of responsibility changes. 

[!Paradigm](paradigm.png)

## Simultations using old data

```{r load old data}

data <- NULL

folder <- 'G:/Documents/University/Google Drive/Temp/data/Marwa/Online experiment'
for (f in list.files(folder, full.names = T)) {
  if (!grepl('\\.mat$', f)) {
    next()
  }
  contents <- readMat(f)
  tmp <- tibble(
    pid = as.numeric(contents$subid),
    age = as.numeric(contents$agesub),
    gender = as.numeric(contents$gendsub),
    condition = as.numeric(contents$cond),
    group = as.numeric(contents$group),
    img1 = as.numeric(contents$img1),
    img2 = as.numeric(contents$img2),
    choiceButton = as.numeric(contents$buttchoice),
    choiceRT = as.numeric(contents$rtchoice),
    outcome = as.numeric(contents$outcome),
    scaleOrder = as.numeric(contents$scaleorder),
    scaleResp = as.numeric(contents$scaleresp),
    scaleRT = as.numeric(contents$scalert)
  )
  
  data <- rbind(data, tmp)
}

data <- data %>%
  mutate(pid = factor(pid), 
         gender = factor(gender, labels = c('male', 'female')),
         condition = factor(condition, labels = c('alone', 'two',
                                                  'five',
                                                  'two, other plays',
                                                  'two computers',
                                                  'participant + 4 comps',
                                                  'alone, computer plays')),
         img1 = factor(img1),
         img2 = factor(img2),
         outcome = factor(outcome, labels = c('good', 'bad')),
         scaleOrder = factor(scaleOrder)) %>%
  mutate(agency = !(condition %in% c('two, other plays', 'computer plays')))

data
```

### Review old data

If we've got the data set up right, we should see some interesting results by interacting group, outcome, and scale order against the responsibility levels reported by the participants:

```{r old effect visualisation}
dw <- .4

data %>% mutate(alone = group == 0) %>%
  group_by(pid, scaleOrder, outcome, alone) %>%
  summarise(scaleResp = mean(scaleResp)) %>%
  filter_all(all_vars(!is.nan(.))) %>%
  ggplot(aes(x = scaleOrder, y = scaleResp, 
                    colour = outcome, group = outcome)) +
  stat_summary(geom = 'point', fun.y = mean, position = position_dodge(dw)) +
  stat_summary(geom = 'errorbar', fun.data = mean_cl_normal, width = 0, 
               position = position_dodge(dw)) +
  stat_summary(geom = 'line', fun.y = mean, position = position_dodge(dw)) +
  facet_wrap(~alone, labeller = label_both) +
  scale_y_continuous(limits = c(0, 100))

```

We also want to see some general distribution and variability type stuff for participants. The paradigm we'll use is going to be most similar to the condition with one/two players, so we'll take a closer look at the distributions of responsibility questions.

```{r}

data %>% filter(condition %in% c("two", "alone")) %>%
  ggplot(aes(x = scaleResp)) +
  geom_density(aes(fill = pid), alpha = .25, colour = NA) +
  geom_density(fill = NA, colour = 'black', linetype = 'dashed') +
  guides(fill = 'none') +
  facet_grid(~condition, labeller = label_both) +
  labs(title = 'Density of responses in paried condition',
       subtitle = 'Dashed outline shows overall average, coloured areas show individual participants')

```

### Create model from old data

We use the summaries for relevant conditions in the original data as a model for simulating new data.

```{r model participants in different conditions}

effectSize <- 1
effectSizes <- rnorm(length(unique(data$pid)), mean = effectSize)

model <- data %>% 
  dplyr::filter(condition %in% c('two', 'alone')) %>%
  group_by(pid, group, agency, outcome, scaleOrder) %>%
  summarise(choiceRT_m = mean(choiceRT),
            choiceRT_sd = sd(choiceRT),
            scaleResp_m = mean(scaleResp),
            scaleResp_sd = sd(scaleResp),
            scaleRT_m = mean(scaleRT),
            scaleRT_sd = sd(scaleRT)) %>%
  dplyr::filter_all(all_vars(!is.nan(.))) %>% 
  # add effects
  mutate(effectSize = effectSizes[as.numeric(pid)])

# Collapse reponsibility ratings obtained before outcome over the valence
# because participants didn't know what the outcome valence would be
model <- model %>%
  dplyr::filter(scaleOrder == '1') %>%
  group_by(pid, agency, group) %>%
  summarise_if(is.numeric, mean) %>%
  mutate(
    scaleOrder = factor(1, levels = levels(model$scaleOrder)), 
    outcome = factor('good', levels = levels(model$outcome))
    ) %>%
  rbind(model %>% dplyr::filter(scaleOrder == '2')) # bind back to original

# Take out participants who don't give responses for all contingencies.
# 2xGroup x 2xOutcome + 1.5xScaleOrder
pids <- model %>% 
  ungroup() %>%
  group_by(pid) %>%
  summarise(n = n()) %>%
  dplyr::filter(n == 6)

model <- model %>% dplyr::filter(pid %in% pids$pid)

model

```

### Simulate new data from model

New data are produced from the model by using the 

```{r simulate data with new pattern}

simData <- data %>% 
  dplyr::filter(F) %>%                          # empty current data
  mutate(pGetsOutcome = agency,
         agency = NULL,
         scaleOrderFinal = sample(scaleOrder),
         scaleRespFinal = sample(scaleResp),
         scaleRTFinal = sample(scaleRT))        # add new columns

sdAll <- mean(model$scaleResp_sd)               # for adding of effects

# The code is vectorised over reps, so increasing this has less performance
# impact than we might think. This will be useful for bootstrap sampling in
# empirical power analysis later.
reps <- 10

for (pid in unique(model$pid)) {
  for (group in c(0, 2)) {
    for (pGetsOutcome in c(T, F)) {
      condition <- ifelse(group == 0, 'alone, ', 'paired, ') %>%
        paste0(ifelse(pGetsOutcome, 'p outcome', 'other outcome'))
      
      for (outcome in c('good', 'bad')) {
        pre <- dplyr::filter(model,
                             pid == !!pid, 
                             group == !!group) %>%
          plyr::summarise(choiceRT_m = mean(choiceRT_m),
                    scaleRT_m = mean(scaleRT_m),
                    scaleResp_m = mean(scaleResp_m))
        
        tmp <- dplyr::filter(model, 
                             pid == !!pid,
                             group == !!group,
                             outcome == !!outcome)
        
        # Add in the actual effect 
        # (more responsibility if self gets outcome, regardless of valence)
        if (pGetsOutcome) {
          tmp$scaleResp_m <- tmp$scaleResp_m + (sdAll * tmp$effectSize)
        }
        
        simData <- rbind(simData, 
                         tibble(
                           pid = pid,
                           condition,
                           group,
                           pGetsOutcome,
                           outcome,
                           choiceRT = rnorm(reps, 
                                            pre$choiceRT_m, 
                                            tmp$choiceRT_sd),
                           scaleResp = rnorm(reps, 
                                             pre$scaleResp_m, 
                                             tmp$scaleResp_sd),
                           scaleRT = rnorm(reps, 
                                           pre$scaleRT_m, 
                                           tmp$scaleRT_sd),
                           scaleRespFinal = rnorm(reps, 
                                                  tmp$scaleResp_m, 
                                                  tmp$scaleResp_sd),
                           scaleRTFinal = rnorm(reps, 
                                                tmp$scaleRT_m, 
                                                tmp$scaleRT_sd)
                         ))     
      }
    }
  }
}

# Keep the data within scale limits
simData <- simData %>%
  mutate(
    choiceRT = pmax(choiceRT, 0),
    scaleRT = pmax(scaleRT, 0),
    scaleRTFinal = pmax(scaleRTFinal, 0),
    scaleResp = pmin(100, pmax(0, scaleResp)),
    scaleRespFinal = pmin(100, pmax(0, scaleRespFinal))
  )


simData <- simData %>%
  gather(key = 'decision', 
         value = 'scaleResponse', 
         c(scaleRespFinal, scaleResp)) %>%
  mutate(
    pid = factor(pid),
    decision = factor(decision),
    group = factor(group),
    outcome = factor(outcome),
    pGetsOutcome = factor(pGetsOutcome)
  )

simData

```

### Plot simulated data

Plot simulated data.

```{r simulated data plots}

simData %>% 
  ggplot(aes(x = decision, y = scaleResponse, 
                    colour = outcome, group = outcome)) +
  stat_summary(geom = 'point', fun.y = mean, alpha = .5,
               position = position_dodge(dw)) +
  stat_summary(geom = 'errorbar', fun.data = mean_cl_normal, width = 0, 
               position = position_dodge(dw)) +
  stat_summary(geom = 'line', fun.y = mean, position = position_dodge(dw)) +
  facet_wrap(group~pGetsOutcome, labeller = label_both) +
  scale_y_continuous(limits = c(0, 100))

```

### Analysis of simulated data

Test simulated data.

```{r simultaed data ANOVA}

result <- simData %>% 
  ezANOVA(
  dv = scaleResponse,
  wid = pid,
  within = c(
    decision,
    outcome,
    group,
    pGetsOutcome
  )
)

result

```
