---
title: "Analysis of Experiment 3 data"
author: "Matt Jaquiery"
date: "21/06/2020"
output: html_document
---

[Script run `r Sys.time()`]

```{r, include=F}
knitr::opts_chunk$set(echo = F)
```

```{r, include=F}
library(checkpoint)         # Ensure CRAN packages have the right versions
# checkpoint('2020-05-08')  # All packages will be loaded as they stood at this date
library(tidyverse)
library(ggridges)
library(ez)
library(BayesFactor)
theme_set(theme_light() + theme(
  panel.grid = element_blank()
))

#' Compare models within a anovaBF output to get relative likelihood
#' @param x the BFBayesFactor object containing the results
#' @param comparisons list of pairs of values for the comparisons. Values can be row numbers or model strings.
#' @return data frame with columns M1, M2, BF(M1,M2)
marginalBF <- function(x, comparisons) {
  ns <- rownames(x@bayesFactor)
  getIndex <- function(i) if (i %in% ns) which(ns == i) else i
  bf <- function(a, b) exp(a - b)
  out <- NULL
  for (comp in comparisons) {
    if (length(comp) < 2) {
      stop(paste0("Comparison of length <2 (", length(comp), ") requested."))
    }
    a <- getIndex(comp[1]); b <- getIndex(comp[2]);
    out <- rbind(out, data.frame(
      M1 = ns[a], M2 = ns[b],
      BF.M1.M2 = bf(x@bayesFactor$bf[a], x@bayesFactor$bf[b])
    ))
  }
  out
}
```

# Introduction

# Method

## Open science

### Preregistration

### Open materials

### Open data

# Results

## Descriptive statistics

Load data...

```{r read data}

d <- read.csv('../data/dataEXP3.csv', sep = ";", stringsAsFactors = F) %>% 
  as_tibble() 

# Remove testing data
d <- d %>% filter(prolificid != "", prolificid != "Matt")

# !TODO[consider removing 5edbd8c9ec975e0955b42302 who did task twice]

d

if (any(d$participant_id != 1, na.rm = T))
  stop("Some participants have the wrong id (should be 1). This must be corrected before this analysis will work correctly.")

```

### Exclusions

```{r descriptive stats}

d.old <- d

max_missed_trials <- 10
max_consec_resp <- 10
expected_trial_n <- 56

# max_missed_trials
exclude_ids <- d %>% 
  nest(df = -subject_id) %>%
  mutate(missed_trials = 
           map_dbl(df, . %>% filter(is.na(responsibility_time_p0),
                                    is.na(responsibility_time_p1),
                                    is.na(responsibility_time_p2),
                                    is.na(responsibility_rating_p0),
                                    is.na(responsibility_rating_p1),
                                    is.na(responsibility_rating_p2),
                                    vote_p0 == "",
                                    vote_p1 == "",
                                    vote_p2 == "") %>% nrow()),
         missed_trials = missed_trials >= max_missed_trials) %>%
  filter(missed_trials) %>%
  select(-df)

# expected_trial_n
exclude_ids <- full_join(
  exclude_ids, 
  d %>%
    nest(df = -subject_id) %>%
    mutate(df = map_dbl(df, nrow)) %>%
    filter(df < expected_trial_n) %>%
    mutate(trial_count = T) %>%
    select(-df),
  by = "subject_id"
  )

# We now remove missed trials
# Whether we do this BEFORE or AFTER checking consecutive responses matters
d <- d %>% filter(!is.na(responsibility_time_p0),
                  !is.na(responsibility_time_p1),
                  !is.na(responsibility_time_p2),
                  !is.na(responsibility_rating_p0),
                  !is.na(responsibility_rating_p1),
                  !is.na(responsibility_rating_p2),
                  vote_p0 != "",
                  vote_p1 != "",
                  vote_p2 != "")

# max_consec_resp
exclude_ids <- full_join(
  exclude_ids,
  d %>% 
    arrange(subject_id, trial_index) %>%
    mutate(consec = sequence(rle(vote_p1)$lengths)) %>%
    nest(df = -subject_id) %>%
    mutate(consec_resp = map_lgl(df, ~ any(.$consec >= max_consec_resp))) %>%
    filter(consec_resp) %>%
    select(-df),
  by = "subject_id"
)

exclude_ids

exclude_ids %>% 
  mutate(unique_exclusions = 1) %>% 
  select(unique_exclusions, everything(), -subject_id) %>% 
  summarise_all(sum, na.rm = T)

d <- d %>% 
  filter(!(subject_id %in% exclude_ids$subject_id)) %>% 
  mutate(
    subject_id = factor(subject_id),
    status = factor(status, labels = c('p_in_majority', 'p_in_minority')),
    outcome = factor(outcome, labels = c('reward', 'no reward')),
    getsout = factor(getsout, labels = c('p0', 'participant', 'p2'))
  )

```

Before exclusion we have `r length(unique(d.old$subject_id))` subject_ids. We now exclude participants who have more than `r max_missed_trials` missed trials, more than `r max_consec_resp` consecutive left or right responses, or fewer than `r expected_trial_n` trials recorded. Our final participant list contains `r length(unique(d$subject_id))` participants.

### Response times

Participants make four responses on a trial, choosing a gamble and indicating how responsible each of the players was for the decision. 

```{r all-rt, fig.height=14, fig.width=6}

tmp <- d %>% 
  select(subject_id, time_choice_start, time_choice_made, starts_with('responsibility_time')) %>%
  pivot_longer(c(time_choice_made, starts_with('responsibility_time')),
               names_to = "event", 
               values_to = "time_from_choice_start") %>%
  mutate(time_from_choice_start = time_from_choice_start - time_choice_start) %>%
  mutate(event = case_when(
    str_detect(event, 'responsibility_time') ~ str_extract(event, 'p[0-9]+$'),
    T ~ event)
  )

ggplot(tmp, aes(y = subject_id, x = time_from_choice_start, fill = event, colour = event)) +
  geom_vline(xintercept = 2000, linetype = 'dashed', colour = 'grey75') +
  geom_density_ridges(alpha = .25) +
  geom_point(position = position_jitter(0, .05), alpha = .25) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = 'top'
  )

```

### Feeling of responsibility scale usage

```{r, fig.height=14, fig.width=6}

tmp <- d %>% 
  pivot_longer(starts_with('responsibility_rating_p'),
               names_to = 'rated_player',
               values_to = 'response') %>%
  mutate(rated_player = str_extract(rated_player, 'p[0-9]+$')) %>%
  select(subject_id, response, rated_player) %>%
  nest(df = -subject_id) %>%
  mutate(sum = map_dbl(df, ~ sum(.$response))) %>%
  unnest(cols = df)
tmp$subject_id <- reorder(tmp$subject_id, tmp$sum)
  
ggplot(tmp, aes(x = response, y = factor(subject_id), 
                colour = rated_player, fill = rated_player)) +
  geom_density_ridges(alpha = .25) +
  scale_x_continuous(limits = c(0, 100)) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = 'top'
  )

```

## Inferential statistics

* 2 (outcome) x 2 (participant majority) x 3 (recipient)  
* ANOVA:  
    * 2x outcome  
    * 2x isParticipant  
    * 2x getsOutcome  
    * 2x participantInMajority  

```{r}
d.long <- d %>% 
  pivot_longer(cols = starts_with('responsibility_rating_p'),
               names_to = 'rated_player',
               values_to = 'responsibility_rating') %>%
  mutate(rated_player = str_extract(rated_player, 'p[0-9]+$'),
         is_participant = factor(if_else(rated_player == 'p1',
                                         'participantRated',
                                         'otherRated')))

dw <- .25
d.long %>%
  group_by(subject_id, status, outcome, getsout, is_participant) %>% 
  summarise(response = mean(responsibility_rating)) %>%
  ggplot(aes(x = outcome, y = response, colour = getsout)) +
  geom_hline(yintercept = 20, linetype = 'dashed') +
  geom_point(alpha = .1, position = position_jitterdodge(dw/1.5, dodge.width = dw)) +
  stat_summary(geom = "point", aes(group = getsout), size = 5, fun.y = mean,
               position = position_dodge(dw)) +
  stat_summary(geom = "errorbar", aes(group = getsout), width = 0, fun.data = mean_cl_normal,
               position = position_dodge(dw)) +
  stat_summary(geom = 'line', fun.y = mean, aes(group = getsout), position = position_dodge(dw)) +
  facet_grid(is_participant~status)

```

```{r}

a <- ezANOVA(
  data = d.long,
  dv = responsibility_rating,
  wid = subject_id,
  within = c(
    outcome,
    getsout,
    status,
    is_participant
  )
)

a

a.bf = anovaBF(
  data = d.long,
  formula = responsibility_rating ~ 
    outcome + getsout + status + is_participant + subject_id,
  whichRandom = 'subject_id', progress = F
)

a.bf
```

# Discussion

# Credits 

## Acknowledgements



## R Packages

```{r results = 'asis'}
# list packages
packageNames <- (.packages())
# don't include very core package
packageNames <- packageNames[!(packageNames %in% 
                                 rownames(installed.packages(
                                   priority = "base")))]
# but do include the base package
packageNames <- c("base", packageNames)
out <- NULL
for (p in packageNames) {
  out <- rbind(out, data.frame('Package' = p, 
                               'Citations' = paste(format(citation(p), 
                                                          style = 'textVersion'), 
                                                   collapse = '<br/><br/>')))
}

as_tibble(out)
```

## Funding

Marwa El Zein is funded by ... 

Matt Jaquiery is funded by a studentship from the [Medical Research Council](https://mrc.ukri.org/) (reference 1943590) and the University of Oxford [Department of Experimental Psychology](https://www.psy.ox.ac.uk/) (reference 17/18_MSD_661552).

## Technical details  

```{r results = 'hold'}
cat(paste('Time stamp:', Sys.time(), '\n\n'))
cat('Runtime \n')
proc.time()
cat('\n')
sessionInfo()
```